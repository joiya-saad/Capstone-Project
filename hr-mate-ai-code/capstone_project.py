# -*- coding: utf-8 -*-
"""Capstone Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10L69iKx1fWgLD3JMZvHTVN_cVwlqqR4w

# Importing Libraries
"""

# Uninstall pandas and numpy
!pip uninstall pandas -y
!pip uninstall numpy -y

!pip install pandas

import pandas as pd
import random
import difflib
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from datetime import datetime, timedelta

"""# Generating Projects and Roles"""

# --- Define Employee Roles with Themes ---
employee_roles = [
    {"Role Name": "Solution Architect", "Role Description": "Designs high-level technical solutions for enterprise customers.", "Theme": "Technical"},
    {"Role Name": "Sales Account Manager", "Role Description": "Manages customer accounts and drives sales processes.", "Theme": "Sales"},
    {"Role Name": "Digital Marketing Specialist", "Role Description": "Executes online campaigns, SEO, and branding strategies.", "Theme": "Marketing"},
    {"Role Name": "Senior HR Manager", "Role Description": "Manages HR operations and employee relations.", "Theme": "HR"},
    {"Role Name": "Legal Counsel", "Role Description": "Provides legal support for contracts and compliance.", "Theme": "Legal"},
    {"Role Name": "IT Systems Engineer", "Role Description": "Maintains and optimizes internal IT infrastructure.", "Theme": "Technical"},
    {"Role Name": "Workflow Consultant", "Role Description": "Analyzes business processes and recommends workflow improvements.", "Theme": "Consulting"},
    {"Role Name": "Project Manager", "Role Description": "Oversees project delivery and coordinates cross-functional teams.", "Theme": "Consulting"},
    {"Role Name": "Data Analyst", "Role Description": "Analyzes data and delivers business insights.", "Theme": "Technical"},
    {"Role Name": "Customer Success Manager", "Role Description": "Supports post-sales success and client satisfaction.", "Theme": "Sales"},
    {"Role Name": "Field Support Engineer", "Role Description": "Provides onsite technical support for Canon products.", "Theme": "Technical"},
    {"Role Name": "Pre-Sales Engineer", "Role Description": "Prepares technical demos and solution proposals for prospects.", "Theme": "Sales"},
    {"Role Name": "Compliance Manager", "Role Description": "Ensures adherence to regulations and company standards.", "Theme": "Legal"},
    {"Role Name": "HR Business Partner", "Role Description": "Collaborates with leadership to align HR strategy.", "Theme": "HR"},
    {"Role Name": "Corporate Trainer", "Role Description": "Designs and delivers employee training programs.", "Theme": "HR"},
    {"Role Name": "Technical Support Specialist", "Role Description": "Resolves technical issues reported by customers.", "Theme": "Technical"},
    {"Role Name": "Content Creator", "Role Description": "Develops written, video, and visual content for marketing.", "Theme": "Marketing"},
    {"Role Name": "Solutions Support Consultant", "Role Description": "Provides technical guidance and second-line support for Canon solutions during and after customer deployment.", "Theme": "Technical"},
    {"Role Name": "Integration Developer", "Role Description": "Develops integrations between Canon products and third-party systems.", "Theme": "Technical"},
    {"Role Name": "Strategy Consultant", "Role Description": "Advises leadership on business growth and optimization strategies.", "Theme": "Consulting"},
]

# --- Define Project Summaries with Themes ---
project_summaries = [
    {"Project Summary": "Implement scalable workflow automation system", "Scope and Deliverables": "Deploy Workflow2000, integrate with client systems", "Theme": "Technical"},
    {"Project Summary": "CRM integration for loyalty program", "Scope and Deliverables": "Customize CRM modules and train sales team", "Theme": "Sales"},
    {"Project Summary": "Launch digital marketing portal", "Scope and Deliverables": "Create website, SEO, lead funnels", "Theme": "Marketing"},
    {"Project Summary": "HR digital onboarding system", "Scope and Deliverables": "Implement HRIS system, self-service portals", "Theme": "HR"},
    {"Project Summary": "Contract management system deployment", "Scope and Deliverables": "Deploy document archiving and e-signature workflows", "Theme": "Legal"},
    {"Project Summary": "Upgrade internal IT infrastructure", "Scope and Deliverables": "Replace old servers, migrate systems to cloud", "Theme": "Technical"},
    {"Project Summary": "Business workflow audit", "Scope and Deliverables": "Map processes and suggest automation improvements", "Theme": "Consulting"},
    {"Project Summary": "Manage ERP migration project", "Scope and Deliverables": "Deliver milestones for new ERP roll-out", "Theme": "Consulting"},
    {"Project Summary": "Data warehouse design", "Scope and Deliverables": "Create new analytics-ready database", "Theme": "Technical"},
    {"Project Summary": "Post-sale onboarding program", "Scope and Deliverables": "Develop client onboarding workflow", "Theme": "Sales"},
    {"Project Summary": "Onsite print solutions setup", "Scope and Deliverables": "Install Print2.0 platform for retail client", "Theme": "Technical"},
    {"Project Summary": "Pre-sales technical proof-of-concept setup", "Scope and Deliverables": "Build demo environments for prospects", "Theme": "Sales"},
    {"Project Summary": "Regulatory compliance documentation project", "Scope and Deliverables": "Standardize processes, deliver compliance documentation", "Theme": "Legal"},
    {"Project Summary": "Organizational culture development initiative", "Scope and Deliverables": "Conduct workshops, employee surveys", "Theme": "HR"},
    {"Project Summary": "Employee training", "Scope and Deliverables": "Give overview on Learning Management System (LMS)", "Theme": "HR"},
    {"Project Summary": "Customer remote support setup", "Scope and Deliverables": "Setup online ticketing and remote assistance systems", "Theme": "Technical"},
    {"Project Summary": "Content library migration", "Scope and Deliverables": "Migrate marketing content to new CMS", "Theme": "Marketing"},
    {"Project Summary": "Quality assurance framework rollout", "Scope and Deliverables": "Implement QA policies across departments", "Theme": "Technical"},
    {"Project Summary": "API and system integration project", "Scope and Deliverables": "Develop middleware for integration of ERP/CRM", "Theme": "Technical"},
    {"Project Summary": "Business strategy development program", "Scope and Deliverables": "Assist C-suite with market expansion strategy", "Theme": "Consulting"},
]

# --- Create DataFrames ---
roles_df = pd.DataFrame(employee_roles)
projects_df = pd.DataFrame(project_summaries)

roles_df.head()

# Controlled Product Pools per Theme
product_pools = {
    "Technical": ["Workflow2000", "Print2.0", "AIScan", "CloudSuite", "IntegrationHub"],
    "Sales": ["CRM Pro", "Sales Enablement Suite", "Loyalty CRM", "SalesForce Light"],
    "Marketing": ["Digital Campaign Manager", "SEO Toolkit", "Content CMS", "Social Media Manager"],
    "HR": ["HRIS Plus", "Onboarding Suite", "Employee Experience Platform"],
    "Legal": ["Compliance Suite", "Contract Manager Pro", "Regulatory Tracker"],
    "Consulting": ["ERP Migration Tool", "Business Analysis Framework", "Strategy Kit"]
}

# Controlled Skill Pools per Theme
skill_pools = {
    "Technical": ["Data Analysis", "Workflow Automation", "Cloud Services", "IT Infrastructure", "API Development"],
    "Sales": ["CRM Integration", "Negotiation", "Client Management", "Customer Relationship Management"],
    "Marketing": ["SEO Optimization", "Content Strategy", "Campaign Management", "Copywriting", "Branding"],
    "HR": ["Digital HR", "Organizational Development", "Talent Management", "Communication Skills"],
    "Legal": ["Contract Management", "Regulatory Knowledge", "Document Review", "Compliance Documentation"],
    "Consulting": ["Business Analysis", "Strategic Planning", "Workflow Optimization", "Project Management", "Change Management"]
}

# New: Controlled Certifications Pool per Theme
certification_pools = {
    "Technical": ["ITIL", "ISO 27001", "Microsoft Azure Certification"],
    "Sales": ["Certified Sales Professional (CSP)", "CRM Specialist Certification"],
    "Marketing": ["Digital Marketing Certification", "Google Ads Certification", "HubSpot Marketing Certification"],
    "HR": ["PMP", "SHRM-CP", "HR Analytics Certification"],
    "Legal": ["Certified Compliance Officer", "GDPR Certification", "Contract Law Certification"],
    "Consulting": ["PMP", "Six Sigma", "Agile Practitioner", "Business Analysis Certification"]
}

# New: Controlled Expertise Areas Pool per Theme
expertise_pools = {
    "Technical": ["Scripting", "API Integration", "Cloud Infrastructure", "Networking", "Cybersecurity"],
    "Sales": ["CRM Integration", "Sales Pipeline Automation", "Client Relationship Systems"],
    "Marketing": ["SEO Optimization", "Content Management Systems", "Social Media Integration"],
    "HR": ["HRIS Systems", "Employee Experience Platforms", "Organizational Development Systems"],
    "Legal": ["Document Archiving", "Contract Management Systems", "Regulatory Compliance Tools"],
    "Consulting": ["Strategic Planning", "Business Workflow Optimization", "ERP Systems Integration"]
}


# Predefined vocabularies
locations_master = ["Berlin", "Vienna", "London"]
work_flexibility_options = ["onsite", "remote", "hybrid"]
languages_master = ["English", "French", "German", "Italian"]
fluency_levels = ["A1", "A2", "B1", "B2", "C1", "C2"]
industries_master = ["Healthcare", "Education", "Finance", "Manufacturing", "Retail"]

# --- Typo Function ---
def introduce_typo(text):
    if len(text) < 4:
        return text
    idx = random.randint(0, len(text) - 2)
    return text[:idx] + text[idx+1] + text[idx] + text[idx+2:]

# --- Smart Project Generator (Full Version) ---
def generate_smart_projects_full(n, project_templates):
    projects = []
    for i in range(n):
        proj = random.choice(project_templates)
        theme = proj["Theme"]

        products = [introduce_typo(p) if random.random() < 0.4 else p
                    for p in random.sample(product_pools[theme], k=min(len(product_pools[theme]), random.randint(1, 3)))]

        required_skills = {
            (introduce_typo(skill) if random.random() < 0.4 else skill): random.randint(5, 10)
            for skill in random.sample(skill_pools[theme], k=min(len(skill_pools[theme]), random.randint(2, 5)))
        }

        certifications = random.sample(certification_pools[theme], k=min(len(certification_pools[theme]), random.randint(1, 2)))
        expertise = random.sample(expertise_pools[theme], k=min(len(expertise_pools[theme]), random.randint(1, 2)))

        project_industry = introduce_typo(random.choice(industries_master)) if random.random() < 0.4 else random.choice(industries_master)

        project = {
            "ProjectID": f"P{i+1}",
            "Project Summary": proj["Project Summary"],
            "Scope and Deliverables": proj["Scope and Deliverables"],
            "Theme": theme,
            "Products Involved": products,
            "Required Skills and Expertise": required_skills,
            "Customer Preferences (Certifications)": certifications,
            "Integration Requirements (Expertise Areas)": expertise,
            "Customer Industry": project_industry,
            "Work Location": introduce_typo(random.choice(locations_master)) if random.random() < 0.3 else random.choice(locations_master),
            "Work Flexibility": random.choice(work_flexibility_options),
            "Languages Required": {introduce_typo(lang) if random.random() < 0.3 else lang: random.choice(fluency_levels)
                                   for lang in random.sample(languages_master, k=random.randint(1, 3))},
            "Complexity": random.randint(1, 10),
            "Effort": random.choice(list(range(20, 241, 10))),
            "Requested End": datetime.now().date() + timedelta(days=random.randint(15, 90))
        }

        projects.append(project)
    return pd.DataFrame(projects)

# --- Smart Employee Generator (Full Version) ---
def generate_smart_employees_full(n, role_templates):
    employees = []
    for i in range(n):
        emp = random.choice(role_templates)
        theme = emp["Theme"]

        product_experience = random.sample(product_pools[theme], k=min(len(product_pools[theme]), random.randint(1, 3)))
        core_competencies = {skill: random.randint(4, 10) for skill in random.sample(skill_pools[theme], k=min(len(skill_pools[theme]), random.randint(2, 5)))}
        certifications = random.sample(certification_pools[theme], k=min(len(certification_pools[theme]), random.randint(1, 2)))
        expertise = random.sample(expertise_pools[theme], k=min(len(expertise_pools[theme]), random.randint(1, 2)))

        industry_experience = random.sample(industries_master, k=random.randint(1, 3))

        employee = {
            "EmployeeID": f"E{i+1}",
            "Role Name": emp["Role Name"],
            "Role Description": emp["Role Description"],
            "Theme": theme,
            "Products Experience": product_experience,
            "Core Competencies": core_competencies,
            "External/Internal Certifications": certifications,
            "Expertise Areas": expertise,
            "Industry Experience": industry_experience,
            "Work Location": random.choice(locations_master),
            "Work Flexibility": random.choice(work_flexibility_options),
            "Languages Known": {lang: random.choice(fluency_levels)
                                for lang in random.sample(languages_master, k=random.randint(1, 3))},
            "Available From": datetime.now().date() + timedelta(days=random.randint(0, 30)),
            "Weekly Availability in Hours": random.choice([10, 20, 30, 40]),

             #Bonus Soft Skill Fields:
            "Cultural Awareness": random.randint(1, 10),
            "Problem Solving": random.randint(1, 10),
            "Leadership": random.randint(1, 10),
        }

        employees.append(employee)
    return pd.DataFrame(employees)

smart_projects_df = generate_smart_projects_full(20, project_summaries)
smart_employees_df = generate_smart_employees_full(20, employee_roles)

smart_projects_df.head()

smart_employees_df.head()

"""# Creating Scoring Functions"""

fuzzy_match_threshold = 0.7

# Normalizing text and doing fuzzy match
def normalize(text):
    return text.lower().strip()

def fuzzy_match(val1, val2, threshold = fuzzy_match_threshold):
    val1, val2 = normalize(val1), normalize(val2)
    return difflib.SequenceMatcher(None, val1, val2).ratio() >= threshold

"""### Product Matching"""

def product_score(project_products, employee_products):
    match_count = 0
    for p_prod in project_products:
        if any(fuzzy_match(p_prod, e_prod) for e_prod in employee_products):
            match_count += 1
    return match_count / len(project_products) if project_products else 0

"""### Location Matching with Work Flexibility Logic"""

def location_score(project_location, project_flex, employee_location, employee_flex):
    if project_flex == "remote":
        return 1.0
    location_match = fuzzy_match(project_location, employee_location)

    if project_flex == "onsite":
        if employee_flex == "onsite" and location_match:
            return 1.0
        elif employee_flex == "hybrid" and location_match:
            return 0.5
        else:
            return 0.0
    elif project_flex == "hybrid":
        if employee_flex == "onsite" and location_match:
            return 1.0
        elif employee_flex == "hybrid" and location_match:
            return 1.0
        elif employee_flex == "remote" and location_match:
            return 0.5
        else:
            return 0.0
    return 0.0

"""### Language Matching and Fluency Scoring"""

cefr_scale = {"A1": 1, "A2": 2, "B1": 3, "B2": 4, "C1": 5, "C2": 6}

def best_fuzzy_match(input_lang, employee_langs, threshold= fuzzy_match_threshold):
    best_match = None
    best_score = 0
    for e_lang in employee_langs:
        score = difflib.SequenceMatcher(None, normalize(input_lang), normalize(e_lang)).ratio()
        if score > best_score:
            best_match = e_lang
            best_score = score
    return best_match if best_score >= threshold else None

def language_score(project_langs, employee_langs):
    matched = []
    for p_lang, p_level in project_langs.items():
        matched_lang = best_fuzzy_match(p_lang, employee_langs)
        if matched_lang:
            matched.append((p_lang, matched_lang, p_level, employee_langs[matched_lang]))

    if not matched:
        return 0.0

    coverage = len(matched) / len(project_langs)
    scores = []
    for _, _, p_level, e_level in matched:
        required = cefr_scale.get(p_level, 0)
        actual = cefr_scale.get(e_level, 0)
        if actual >= required:
            score = 1.0
        else:
            score = max(0, 1 - (required - actual) / 6)
        scores.append(score)
    avg_fit = sum(scores) / len(scores)
    return round(coverage * avg_fit, 2)

"""### Industry Matching Score"""

def fuzzy_in_list(value, lst, threshold=fuzzy_match_threshold):
    for item in lst:
        if difflib.SequenceMatcher(None, value.lower(), item.lower()).ratio() >= threshold:
            return True
    return False

def industry_score(project_industry, employee_industries, threshold=fuzzy_match_threshold):
    return 1.0 if fuzzy_in_list(project_industry, employee_industries, threshold) else 0.0

"""### Required Skills Matching"""

# Skill Match Score with fuzzy key match

def skill_match_score_with_fuzzy_keys(project_skills_dict, complexity, core_competency):
    matched_pairs = []
    for p_skill, required_level in project_skills_dict.items():
        match = best_fuzzy_match(p_skill, core_competency)
        if match:
            matched_pairs.append((p_skill, match, required_level, core_competency[match]))
    if not matched_pairs:
        return 0.0
    coverage = len(matched_pairs) / len(project_skills_dict)
    expertise_scores = []
    for _, _, required, actual in matched_pairs:
        score = 1.0 if actual >= required else 1 - (required - actual) / 10
        expertise_scores.append(score)
    expertise_fit = sum(expertise_scores) / len(expertise_scores)
    capability = coverage * expertise_fit
    complexity_target = complexity / 10
    return 1.0 if capability >= complexity_target else round(capability / complexity_target, 2)

"""### Customer Preferences (Integration Requirements) Matching"""

# Certification Match Score (Set Overlap)
def certification_score(project_certs, employee_certs, threshold = fuzzy_match_threshold):
    if not project_certs:
        return 1.0  # if project does not require certifications, full score
    match_count = 0
    for p_cert in project_certs:
        if any(fuzzy_match(p_cert, e_cert) for e_cert in employee_certs):
            match_count += 1
    return match_count / len(project_certs)

"""### Expertise Requirement Matching"""

# Expertise Areas Match Score (Set Overlap)
def expertise_score(project_expertise, employee_expertise, threshold = fuzzy_match_threshold):
    if not project_expertise:
        return 1.0  # if project does not require expertise, full score
    match_count = 0
    for p_area in project_expertise:
        if any(fuzzy_match(p_area, e_area) for e_area in employee_expertise):
            match_count += 1
    return match_count / len(project_expertise)

"""### Project Summary and Scope & Deliverables Matching with Employee Job Role"""

# Define once globally (for reuse)
tfidf_vectorizer = TfidfVectorizer()

def text_similarity_tfidf(text1, text2):
    vectors = tfidf_vectorizer.fit_transform([text1, text2])
    sim_score = cosine_similarity(vectors[0:1], vectors[1:2])[0][0]
    return round(sim_score, 3)

"""### Availability Filtering"""

from datetime import datetime, timedelta

def availability_score(project_effort, project_end, employee_available_from, employee_weekly_capacity):
    """
    Calculate availability score based on required effort and actual employee availability.
    Uses working days logic:
    - Converts calendar days into estimated working days (5 per 7)
    - Converts those working days into work weeks
    - Checks if employee can handle effort in the available time
    Returns:
        1.0 if the employee is available and has enough capacity
        0.0 otherwise
    """
    if employee_available_from > project_end:
        return 0.0

    days_available = (project_end - employee_available_from).days
    if days_available <= 0:
        return 0.0

    working_days = days_available * (5 / 7)       # Approximate working days
    weeks_available = working_days / 5            # Convert to working weeks

    if weeks_available <= 0:
        return 0.0

    required_weekly_effort = project_effort / weeks_available

    if required_weekly_effort <= employee_weekly_capacity:
        return 1.0
    else:
        return round(employee_weekly_capacity / required_weekly_effort, 2)

"""# Creating Merged Table For Scoring All Employees by Project"""

smart_projects_df["key"] = 1
smart_employees_df["key"] = 1
merged_df = pd.merge(smart_projects_df, smart_employees_df, on="key").drop(columns="key")

merged_df.head()

"""# Scoring Each Employee per Project"""

scores = []

for _, row in merged_df.iterrows():
    # Text similarity from summary and scope to role description
    summary_sim = text_similarity_tfidf(row["Project Summary"], row["Role Description"])
    scope_sim = text_similarity_tfidf(row["Scope and Deliverables"], row["Role Description"])
    role_fit_score = round((summary_sim + scope_sim) / 2, 3)


    availability = availability_score(row["Effort"],row["Requested End"],row["Available From"],row["Weekly Availability in Hours"])

    scores.append({
        "ProjectID": row["ProjectID"],
        "EmployeeID": row["EmployeeID"],


        "Product Match Score": round(product_score(row["Products Involved"], row["Products Experience"]), 2),
        "Location Match Score": round(location_score(row["Work Location_x"], row["Work Flexibility_x"],
                                                     row["Work Location_y"], row["Work Flexibility_y"]), 2),
        "Language Match Score": language_score(row["Languages Required"], row["Languages Known"]),
        "Industry Match Score": industry_score(row["Customer Industry"], row["Industry Experience"]),
        "Skill Match Score": skill_match_score_with_fuzzy_keys(row["Required Skills and Expertise"], row["Complexity"], row["Core Competencies"]),


        "Certification Match Score": certification_score(row["Customer Preferences (Certifications)"], row["External/Internal Certifications"]),
        "Expertise Match Score": expertise_score(row["Integration Requirements (Expertise Areas)"], row["Expertise Areas"]),
        "Job Description Match Score": role_fit_score,
        "Cultural Awareness Score": row["Cultural Awareness"]/10,
        "Problem Solving Score": row["Problem Solving"]/10,
        "Leadership Score": row["Leadership"]/10,
        "Availability Score": availability,
        "Available": 1 if availability == 1.0 else 0,

    })

# Final dataframe
scored_df = pd.DataFrame(scores)
scored_df.head()

scored_df.head()

merged_df = merged_df.merge(scored_df, how = 'left', left_on = ['ProjectID','EmployeeID'], right_on = ['ProjectID','EmployeeID'])

pd.set_option('display.max_columns', None)
pd.DataFrame(merged_df.head(100))

merged_df.sort_values(by = 'Job Description Match Score', ascending = False).head()

merged_df.to_csv('MVPScoring2.csv')

# prompt: i want to print columns and one sample value for merged_df

print("Columns in merged_df:")
for col in merged_df.columns:
  print(col)

print("\nSample values from the first row of merged_df:")
if not merged_df.empty:
  first_row = merged_df.iloc[0]
  for col in merged_df.columns:
    print(f"{col}: {first_row[col]}")
else:
  print("merged_df is empty.")

